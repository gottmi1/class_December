<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>

        //  함수형 프로그래밍이란 무엇인가요?
        // 함수형 프로그래밍은 함수의 출력 값이 오직 함수로 넘어온 아규먼트에만 의존하는 프로그래밍 패러다임입니다. 함수를 몇번 호출하든 항상 같은 결과를 낳습니다. 


        // 1) MAP

        const myArr = [1,2,3,4];

        // const myArrTwo = myArr.map((value,index,array) => {
        //     return value * 2;
        // })

        const myArrTwo = myArr.map( num => {
            return num *2;
        })
        // myArrTwo라는 새로운 배열에 myArr *2에 해당하는 값을 담아주었따.

        console.log(myArr);
        console.log(myArrTwo);

        const songs = [
        {id: 1, name: "red", singer: "taylor"},
        {id: 1, name: "blue", singer: "taylor"},
        {id: 1, name: "yellow", singer: "tayor"},
        {id: 1, name: "orange", singer: "taylor"},
        ]
        // songs 배열의 객체안의 name만 문자열 배열로 만들어 볼거임.

        const allSongsName = songs.map(songs => {
            return songs.name;
        })
        // 같은 방식에 유틸함수를 포함해 singer만 대문자로 받아와 볼거임
        const allSinger = songs.map(songs => {
            return songs.singer.toUpperCase(); // 괄호 안 붙이면 그냥 함수가 리턴됨
        })
        console.log(songs);
        console.log(allSongsName);
        console.log(allSinger);



        // 2) filter : 특정한 아이템을 필터링해주는 역할을 한다. map이랑 비슷해

        const evenArr = myArr.filter ( num => { //위에 선언한 myArr는 [1,2,3,4]
            return num % 2 === 0; //2로 나눴을 때 0으로 떨어지는 숫자만 받아올거
        })

        console.log(evenArr);

        //Filter는 map과 같은 인자를 받습니다 그리고 매우 비슷하게 동작합니다. 
        // 유일한 다른 점은 콜백이 ★true 또는 false로★ 반환되어야 한다는 것입니다. 
        // 만일 true를 반환한다면 배열이 그 원소를 계속 갖고 있고, 만일 false를 반환한다면 필터링됩니다.
        // 한마디로 리턴 조건이 맞는 놈 = ture = 남겨놓음 = 출력 , 틀린놈 = false = 걸러냄 = 출력 안함 임

        let numbers = [1,2,3,4,5,6,7,8,9];

        const evenNum = numbers.filter(num => {
            return num % 2 === 0;
        })
        console.log(evenNum);

        // includes를 통해 문자열도 검사할 수 있다

        let strings = ["banana","habana","bubana","dudaba"];

        const filtered = strings.filter( str => {
            return str.includes("bana"); // strings에서 bana가 있는 세개의 문자열만 반환함
        })

        console.log(filtered);

        const taylorSongs = songs.filter(songs => {
            // return songs.singer === "taylor"; songs배열안의 객체중에 singer 프로퍼티가 taylor인 객체만 뽑아옴.
            return songs.singer.toUpperCase() === "TAYLOR"; // 대문자, 소문자가 섞여있을 수도 있으니까 투어퍼케이스를 적용하고, 전부 대문자로 쓰는게 찾기 편할 것 같음
        })
        console.log(taylorSongs);

        // 3)Reduce reduce는 배열 하나를 받아서 하나의 값으로 바꿔줍니다. 예를 들어, 숫자의 배열을 가지고 있을 때, 쉽게 모든 값의 평균을 구할 수 있습니다.

        const sum = numbers.reduce((acc,curValue) => {
            return acc + curValue; // numbers의 모든 배열의 합을 구하는 함수임. (( abc ) => {}, 0) <-- 0이 들어가는 이유 : 0은 초기값(처음 더해질 값 인듯)
        }, 0);

        console.log(sum);

    </script>

</body>
</html>